---
description: Get started building cross-chain applications
---

# Build with deBridge ðŸ› 

**deBridge** is a protocol and decentralized infrastructure that enables any arbitrary cross-chain interactions in a single transaction. Due to the ability to simultaneously send arbitrary data and liquidity, deBridge acts as a unified framework for all cross-chain needs, which is capable of interconnecting any smart contracts on any blockchains.&#x20;

### Interact with deBridge Infrastructure

![Cross-chain smart contract calls through deBridge](<.gitbook/assets/CHAIN FROM.png>)

Interaction with deBridge infrastructure is as simple as calling the `send` method of `debridgeGate` smart-contract deployed in all supported blockchains. The method can be called by any arbitrary address â€” either EOA or smart contracts

```solidity
function send(
    address _tokenAddress,
    uint256 _amount,
    uint256 _chainIdTo,
    bytes memory _receiver,
    bytes memory _permit,
    bool _useAssetFee,
    uint32 _referralCode,
    bytes calldata _autoParams
) external payable;
```

The method accepts the following parameters:

| Parameter Name | Type    | Description                                                                                                                                            |
| -------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| \_tokenAddress | address | Address of the token being sent (`address(0)` for chain base assets like ETH)                                                                          |
| \_amount       | uint256 | Token amount to be transferred                                                                                                                         |
| \_chainIdTo    | uint256 | Id of the receiving chain                                                                                                                              |
| \_receiver     | bytes   | Address of the receiver                                                                                                                                |
| \_permit       | bytes   | In case the token being passed supports [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612), signed permits can be used instead of allowance approvals |
| \_useAssetFee  | bool    | Should also be set to `False`. (Reserved for future use by governance to accept fees in the form of the transferred token)                             |
| \_referralCode | uint32  | Your generated referral code                                                                                                                           |
| \_autoParams   | bytes   | Structure that allows passing arbitrary messages and call data                                                                                         |

{% hint style="info" %}
You can always check examples of cross-chain applications provided below to see how parameters are set for the send method. [Here is](https://github.com/debridge-finance/debridge-contracts-v1/blob/aa8e7ca566807898f57e0f7d01a9533553b11ac9/contracts/examples/Incrementor.sol#L37) an example of send method for [**incrementor**](https://github.com/debridge-finance/debridge-contracts-v1/tree/main/examples) smart contract.
{% endhint %}

{% hint style="success" %}
If you integrate with or build applications on top of deBridge infrastructure, make sure you specify your referral code that can be generated by pressing the WAGMI button at https://app.debridge.finance/. Governance may thank you later for being an early builder.
{% endhint %}

`_autoParams` is a structure that allows passing arbitrary messages and call data to be executed as an external call to the receiver address in the destination chain. This structure also allows setting and executionFee - a reward suggested to any wallet or keeper that will complete the transaction in the target chain. It enables crypto-economic design where gas fees are paid from the blockchain where the transaction is initiated. The `_autoParams` field has the following structure

```solidity
struct SubmissionAutoParamsTo {
    uint256 executionFee;
    uint256 flags;
    bytes fallbackAddress;
    bytes data;
}
```

| Parameter Name  | Type    | Description                                                                                                |
| --------------- | ------- | ---------------------------------------------------------------------------------------------------------- |
| executionFee    | uint256 | Suggested reward (in Tokens) paid to anyone who will execute transaction in the destination chain          |
| flags           | uint256 | Flags set specific flows for call data execution                                                           |
| fallbackAddress | bytes   | In case execution of call data fails, all tokens will be transferred to the fallback address               |
| data            | bytes   | Message/Call data to be passed to the receiver in the destination chain during the external call execution |

Flags is a bit mask that allows to achieve specific flow of tranaction execution during the claim in the target chain.

```solidity
library Flags {
    /// @dev Flag to unwrap ETH
    uint256 public constant UNWRAP_ETH = 0;
    /// @dev Flag to revert if external call fails
    uint256 public constant REVERT_IF_EXTERNAL_FAIL = 1;
    /// @dev Flag to call proxy with a sender contract
    uint256 public constant PROXY_WITH_SENDER = 2;
    /// @dev Data is hash in DeBridgeGate send method
    uint256 public constant SEND_HASHED_DATA = 3;
    /// @dev First 24 bytes from data is gas limit for external call
    uint256 public constant SEND_EXTERNAL_CALL_GAS_LIMIT = 4;
}
```

| Flag Name                        | Value | Description                                                                                                                                                                                                                     |
| -------------------------------- | ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| UNWRAP\_ETH                      | 0     | Automatically unwrap blockchain base asset                                                                                                                                                                                      |
| REVERT\_IF\_EXTERNAL\_FAIL       | 1     | Revert transaction if external call was not complete                                                                                                                                                                            |
| PROXY\_WITH\_SENDER              | 2     | Set in case receiving smart contract should validate sending chain id and address                                                                                                                                               |
| SEND\_HASHED\_DATA               | 3     | Pass hash of the call data instead of data itself. Only those who know the original call data will be able to claim transaction in the target chain. If this flag is set, you should have your own keeper to claim transaction. |
| SEND\_EXTERNAL\_CALL\_GAS\_LIMIT | 4     | Specify minimal gas limit to be passed to external call during the transaction claim                                                                                                                                            |

`PROXY_WITH_SENDER` should be set whenever the receiving smart contract should check whether the message sender is trusted or not. If the flag was set, during the claim transaction in the destination chain, deBridge protocol will automatically store the submissionNativeSender address and submissionChainIdFrom, so that receiving smart contract can read the properties and validate if the sender is trusted.

![](.gitbook/assets/image.png)

Receiving smart contract should retrieve the address of callProxy from debridgeGate smart contract. You can use [onlyControllingAddress](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol#L62) modifier or inherit from [BridgeAppBase.sol ](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol)to properly implement this validation logic

### Cross-Chain Smart Contracts Examples

* [Incrementor](https://github.com/debridge-finance/debridge-contracts-v1/tree/main/examples)
* Referral code (Cross-chain referral link generator at [deSwap APP](https://app.debridge.finance))
* NFT bridge

